import com.gtnewhorizons.retrofuturagradle.mcp.ReobfuscatedJar
import org.jetbrains.gradle.ext.Gradle

plugins {
    id("java")
    id("java-library")
    id("org.jetbrains.gradle.plugin.idea-ext") version "1.1.7"
    id("com.gtnewhorizons.retrofuturagradle") version "1.+"
    id("com.matthewprenger.cursegradle") version "1.4.0"
}

// Add version to the jar name
version project.version

// Set the toolchain version to decouple the Java we run Gradle with from the Java used to compile and run the mod
java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(8))
        vendor.set(JvmVendorSpec.ADOPTIUM)
    }
    // Generate sources jar when building and publishing
    withSourcesJar()
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = "UTF-8"
    options.fork = true
    options.forkOptions.jvmArgs += ["-Xmx4G"]
}

minecraft {
    mcVersion = '1.12.2'

    username = "Desoroxxx"

    def args = ['-Dfml.coreMods.load=io.redstudioragnarok.valkyrie.asm.ValkyriePlugin']

    extraRunJvmArguments.addAll("-Xmx24G", "-Xms4G")

    injectedTags.put('ID', project.id)
    injectedTags.put('VERSION', project.version)
}

// Generate a my.project.Tags class with the version number as a field
tasks.injectTags.configure {
    outputClassName.set("io.redstudioragnarok.${project.id}.Tags")
}

// Create configuration to include embedded dependencies into Valkyrie jar
configurations {
    implementation
    compile.extendsFrom(embed)
}

repositories {
    maven {
        name 'Cleanroom'
        url 'https://maven.cleanroommc.com'
    }

    maven {
        name 'SpongePowered'
        url 'https://repo.spongepowered.org/maven'
    }

    ivy {
        url 'https://github.com/'

        patternLayout { artifact '[organisation]/[module]/releases/download/v[revision]/[module]-[revision].[ext]' }

        metadataSources { artifact() }
    }

    ivy {
        url 'https://github.com/'

        patternLayout { artifact '[organisation]/[module]/releases/download/[revision]/[module]-[revision].[ext]' }

        metadataSources { artifact() }
    }
}

dependencies {
    implementation 'Red-Studio-Ragnarok:Red-Core:0.2-Dev-2@jar'

    implementation 'net.jafama:jafama:2.+'
    embed 'net.jafama:jafama:2.+'

    implementation 'zone.rong:mixinbooter:8.2'
    api ("org.spongepowered:mixin:0.8.3") {transitive = false}
    annotationProcessor('org.ow2.asm:asm-debug-all:5.2')
    annotationProcessor('com.google.guava:guava:24.1.1-jre')
    annotationProcessor('com.google.code.gson:gson:2.8.6')
    annotationProcessor ("org.spongepowered:mixin:0.8.3") {transitive = false}
}

def mixinTmpDir = buildDir.path + File.separator + 'tmp' + File.separator + 'mixins'
def refMap = "${mixinTmpDir}" + File.separator + 'mixins.valkyrie.refmap.json'
def mixinSrg = "${mixinTmpDir}" + File.separator + "mixins.srg"

tasks.named("reobfJar", ReobfuscatedJar).configure {
    extraSrgFiles.from(mixinSrg)
}

tasks.named("compileJava", JavaCompile).configure {
    doFirst {
        new File(mixinTmpDir).mkdirs()
    }
    options.compilerArgs += [
            "-AreobfSrgFile=${tasks.reobfJar.srg.get().asFile}",
            "-AoutSrgFile=${mixinSrg}",
            "-AoutRefMapFile=${refMap}",
    ]
}

def at = project.files("src/main/resources/META-INF/valkyrie_at.cfg")

tasks.deobfuscateMergedJarToSrg.accessTransformerFiles.from(at)
tasks.srgifyBinpatchedJar.accessTransformerFiles.from(at)

// Replace version and id in `mcmod.info`
processResources {
    inputs.property 'id', project.id
    inputs.property 'version', project.version
    filesMatching(['mcmod.info', 'pack.mcmeta']) { fcd ->
        include 'mcmod.info'
        fcd.expand (
                'id': project.id,
                'version': project.version
        )
    }
    from refMap
    dependsOn 'compileJava'
}

jar {
    manifest.attributes([
            'ModSide': 'BOTH',
            'FMLAT': 'valkyrie_at.cfg',
            'FMLCorePlugin': 'io.redstudioragnarok.valkyrie.asm.ValkyriePlugin',
            'FMLCorePluginContainsFMLMod': 'true',
            'ForceLoadAsMod': 'true'
    ])

    // Add all embedded dependencies into the jar
    from(provider{ configurations.embed.collect {it.isDirectory() ? it : zipTree(it)} })
}

idea {
    module { inheritOutputDirs = true }

    module {
        excludeDirs = [file(".github"), file(".gradle"), file(".idea"), file("build"), file("gradle"), file("run")]
    }

    project { settings {
        runConfigurations {
            "1. Client"(Gradle) {
                taskNames = ["runClient"]
            }
            "2. Server"(Gradle) {
                taskNames = ["runServer"]
            }
            "3. Obfuscated Client"(Gradle) {
                taskNames = ["runObfClient"]
            }
            "4. Obfuscated Server"(Gradle) {
                taskNames = ["runObfServer"]
            }
        }

        compiler.javac {
            afterEvaluate {
                javacAdditionalOptions = "-encoding utf8"
                moduleJavacAdditionalOptions = [
                        (project.id + ".main"): tasks.compileJava.options.compilerArgs.collect { '"' + it + '"' }.join(' ')
                ]
            }
        }
    }}
}

tasks.named("processIdeaSettings").configure {
    dependsOn("injectTags")
}
